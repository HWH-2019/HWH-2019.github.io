<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>顺序表学习总结</title>
    <link href="/2022/11/17/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2022/11/17/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>顺序表，全名顺序存储结构，是<a href="https://blog.csdn.net/h2763246823/article/details/108021474">线性表</a>中的一种。</p><p>顺序表遵循线性表的存储逻辑关系为“一对一”的数据的特点。同时，顺序表对数据的物理存储结构也有特殊的要求：存储数据前需要申请一块足够大的物理空间，数据依次存入空间中，不留间隙。</p><p>例如，使用顺序表存储集合{1，2，3，4，5}，数据的最终存储状态如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200818202543171.png#pic_center" alt="顺序存储结构示意图"><br>理解顺序表的存储结构时，可以参考数组的存储结构。</p><h2 id="顺序表的建立"><a href="#顺序表的建立" class="headerlink" title="顺序表的建立"></a>顺序表的建立</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="定义数据表"><a href="#定义数据表" class="headerlink" title="定义数据表"></a>定义数据表</h4><p>首先，我们需要明确顺序表的建立所需的组成部分。</p><pre><code class=" mermaid">graph LRA(顺序表)--&gt;B(一段连续的物理空间)A--&gt; C(保存顺序表中元素个数的length,当前长度)A--&gt; D(保存顺序表最大存储元素个数的size,存储容量)</code></pre><p><strong>注</strong>：</p><ol><li>囊括length 和 size 是为了方便后期使用表中的数据</li><li>正常情况下，size要大于length</li></ol><p><strong>步骤</strong>：</p><ol><li>声明一个长度不确定的数组,也叫“动态数组”</li><li>声明一个length保存顺序表的长度</li><li>声明一个size保存顺序表分配的存储容量</li></ol><h4 id="初始化顺序表"><a href="#初始化顺序表" class="headerlink" title="初始化顺序表"></a>初始化顺序表</h4><p><strong>步骤</strong>：</p><ol><li>申请足够大小的物理空间</li><li>分别给size和length赋初值</li></ol><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>明确理论之后，我们就开始建立一个顺序表。<br>注：此处我采用C++模板编写</p><h4 id="定义顺序表"><a href="#定义顺序表" class="headerlink" title="定义顺序表"></a>定义顺序表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Table</span> &#123;<br><span class="hljs-keyword">private</span>:<br>T* head;<span class="hljs-comment">//声明一个长度不确定的数组,也叫“动态数组”</span><br><span class="hljs-type">int</span> length;<span class="hljs-comment">//声明一个length保存顺序表的长度</span><br><span class="hljs-type">int</span> size;<span class="hljs-comment">//声明一个size保存顺序表分配的存储容量</span><br><span class="hljs-comment">//顺序表的一些常规操作声明，目前可以不关注</span><br><span class="hljs-comment">//只是大致的功能，自己创建时可以自行修改。</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Table</span>(<span class="hljs-type">int</span> size);<span class="hljs-comment">//顺序表的初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T value)</span></span>;<span class="hljs-comment">//尾部添加数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T value, <span class="hljs-type">int</span> pos)</span></span>; <span class="hljs-comment">//中间插入数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(T value)</span></span>;<span class="hljs-comment">//删除指定数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(T value, <span class="hljs-type">int</span> pos)</span></span>;<span class="hljs-comment">//改变指定位置的数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//显示表中全部数据</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(T value)</span></span>;<span class="hljs-comment">//查询数据</span><br>T <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i); <span class="hljs-comment">//[]操作符重载</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="初始化顺序表-1"><a href="#初始化顺序表-1" class="headerlink" title="初始化顺序表"></a>初始化顺序表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>Table&lt;T&gt;::<span class="hljs-built_in">Table</span>(<span class="hljs-type">int</span> size) &#123;<br>head = <span class="hljs-keyword">new</span> T[size];<span class="hljs-comment">//动态申请存储空间</span><br>length = <span class="hljs-number">0</span>;<span class="hljs-comment">//空表的长度初始化为0</span><br><span class="hljs-keyword">this</span>-&gt;size = size;<span class="hljs-comment">//空表的存储容量为size</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序表的使用"><a href="#顺序表的使用" class="headerlink" title="顺序表的使用"></a>顺序表的使用</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p><strong>步骤</strong>：</p><ol><li>判断是否需要扩容，需要则扩容，size+1</li><li>将数据存入表中下标为length的位置，length+1</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Table&lt;T&gt;::<span class="hljs-built_in">add</span>(T values) &#123;<br><span class="hljs-keyword">if</span> (length == size) &#123;<br>T* temp = <span class="hljs-keyword">new</span> T[size + <span class="hljs-number">1</span>];<br><span class="hljs-comment">//注意对head中的数据进行保存</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>temp[i] = head[i];<br>&#125;<br><span class="hljs-keyword">delete</span>[] head;<br>head = temp;<br>size++;<br>&#125;<br><span class="hljs-type">int</span> i = length;<br>head[i] = values;<br>length++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p><strong>步骤</strong>：</p><ol><li>判断插入位置是否正确</li><li>判断是否需要扩容，需要则扩容，size+1</li><li>将要插入位置数据以及后续数据整体向后移动一个位置</li><li>将元素放到腾出来的位置上，length+1</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Table&lt;T&gt;::<span class="hljs-built_in">insert</span>(T values, <span class="hljs-type">int</span> pos) &#123;<br><span class="hljs-keyword">if</span> (pos&lt;<span class="hljs-number">1</span> || pos&gt;length + <span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;元素插入位置有误&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (length == size) &#123;<br>T* temp = <span class="hljs-keyword">new</span> T[size + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>temp[i] = head[i];<br>&#125;<br><span class="hljs-keyword">delete</span>[] head;<br>head = temp;<br>size++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= pos - <span class="hljs-number">1</span>; i--) &#123;<br>head[i + <span class="hljs-number">1</span>] = head[i];<br>&#125;<br>head[pos - <span class="hljs-number">1</span>] = values;<br>length++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p><strong>步骤</strong>：</p><ol><li>遍历找到目标数据的位置</li><li>将后续数据整体向前移动一个位置，length-1</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Table&lt;T&gt;::<span class="hljs-built_in">del</span>(T values) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br><span class="hljs-keyword">if</span> (head[i] == values) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; length; j++) &#123;<br>head[j - <span class="hljs-number">1</span>] = head[j];<br>&#125;<br>&#125;<br>&#125;<br>length--;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p><strong>步骤</strong>：</p><ol><li>遍历找到目标数据的位置</li><li>直接修改数据的值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Table&lt;T&gt;::<span class="hljs-built_in">change</span>(T values, <span class="hljs-type">int</span> pos) &#123;<br>head[pos - <span class="hljs-number">1</span>] = values;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h4><p><strong>步骤</strong>：遍历输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Table&lt;T&gt;::<span class="hljs-built_in">show</span>() &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length;i++) &#123;<br>cout &lt;&lt; head[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>注： 可以使用多种算法实现查找，比如说二分查找算法，插值查找算法等。<br>这里使用 顺序查找算法<br><strong>步骤</strong>：遍历匹配目标数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> Table&lt;T&gt;::<span class="hljs-built_in">query</span>(T values) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br><span class="hljs-keyword">if</span> (head[i] == values) &#123;<br><span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Summarize</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础语法总结</title>
    <link href="/2022/11/17/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/11/17/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念和数据类型"><a href="#基本概念和数据类型" class="headerlink" title="基本概念和数据类型"></a>基本概念和数据类型</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>  <strong>标识符（identifier）</strong></p><ol><li>用来表示的有效字符序列：类、变量、方法、数组、文件</li><li>命名规则：<ol><li>以字母、下划线或货币符号开始,后跟上述三种符号和数字(0-9)，字母不限于英文字母，货币符号除$,也可以是其他符号如￥。</li><li>不能使用其他特殊符号，如: +、@、&amp;、空格等。</li><li>不能与Java关键字同名</li><li>英文字母大小写敏感</li><li>长度无最大长度的限制  （建议 小于255个字符）</li></ol></li></ol><ul><li><strong>关键字</strong></li></ul><ol><li>Java语言本身必须使用的标识符</li><li>保留字是Java语言保留起来不允许用户使用的标识符</li><li>关键字（保留字）均用小写字母表示</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><strong>简单数据类型</strong></li></ul><ol><li>整数类型 (Integer)：  byte， short， int (默认) ，long　</li><li>浮点类型 (Floating)：float，double (默认)</li><li>字符类型 (Textual)： char　</li><li>布尔类型 (Logical)： boolean</li></ol><ul><li><strong>引用（复合）数据类型</strong><br>interface  数组  class  Vector  Date  HashMap … …<br>String           Unicode字符集16位   0~65535</li></ul><h2 id="简单数据类型优先级和转换"><a href="#简单数据类型优先级和转换" class="headerlink" title="简单数据类型优先级和转换"></a>简单数据类型优先级和转换</h2><ul><li><p><strong>简单类型数据的优先级</strong><br>byte,short,char  &lt;  int   &lt;  long  &lt; float  &lt; double   (由低到高）</p></li><li><p><strong>自动类型转换</strong><br>当两个简单数据类型的数据进行二元运算，要先将两个操作数转换成同一类型的数据，再进行运算。<br>自动类型转换规则：</p></li></ul><table><thead><tr><th align="center">操作数1类型</th><th align="center">操作数2类型</th><th align="center">类型转换</th></tr></thead><tbody><tr><td align="center">byte、short、char</td><td align="center">int</td><td align="center">int</td></tr><tr><td align="center">byte、short、char、int</td><td align="center">long</td><td align="center">long</td></tr><tr><td align="center">byte、short、char、int、long</td><td align="center">float</td><td align="center">float</td></tr><tr><td align="center">byte、short、char、int、long、float</td><td align="center">double</td><td align="center">double</td></tr></tbody></table><ul><li><strong>强制类型转换</strong><br>高优先级数据要转换成低优先级数据，需用强制类型转换。<br>强制类型转换一般存在数据精度损失。<br>强制类型转换格式：<br>目标类型目标变量名&#x3D;（目标类型）原变量名</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li><strong>算术运算符</strong></li></ul><table><thead><tr><th align="center">运算符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td></tr><tr><td align="center">-</td><td align="center">减</td></tr><tr><td align="center">*</td><td align="center">乘</td></tr><tr><td align="center">&#x2F;</td><td align="center">除</td></tr><tr><td align="center">%</td><td align="center">取余（取模）</td></tr><tr><td align="center">++</td><td align="center">自增</td></tr><tr><td align="center">–</td><td align="center">自减</td></tr></tbody></table><ul><li><strong>位运算符</strong></li></ul><table><thead><tr><th align="center">运算符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">与</td></tr><tr><td align="center">&#96;</td><td align="center">&#96;</td></tr><tr><td align="center">^</td><td align="center">异或</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">算术右移</td></tr><tr><td align="center">&gt;&gt;&gt;</td><td align="center">逻辑右移</td></tr></tbody></table><p>注：对于&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;详解请参见<a href="https://blog.csdn.net/h2763246823/article/details/113813970">《彻底搞懂Java中的＞＞,＜＜,＞＞＞》</a></p><ul><li><strong>赋值运算符</strong></li></ul><table><thead><tr><th align="center">运算符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">赋值</td></tr><tr><td align="center">+&#x3D;</td><td align="center">加赋值</td></tr><tr><td align="center">-&#x3D;</td><td align="center">减赋值</td></tr><tr><td align="center">*&#x3D;</td><td align="center">乘赋值</td></tr><tr><td align="center">&#x2F;&#x3D;</td><td align="center">除赋值</td></tr><tr><td align="center">%&#x3D;</td><td align="center">取余（取模）赋值</td></tr></tbody></table><p>注：以+&#x3D;为例，a+&#x3D;1等价于a&#x3D;a+1。</p><ul><li><strong>关系运算符</strong></li></ul><table><thead><tr><th align="center">运算符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">!&#x3D;</td><td align="center">不等于</td></tr></tbody></table><ul><li><strong>逻辑运算符</strong></li></ul><table><thead><tr><th align="center">运算符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑与</td></tr><tr><td align="center">&#96;</td><td align="center"></td></tr><tr><td align="center">!</td><td align="center">逻辑非</td></tr></tbody></table><ul><li><strong>条件运算符</strong><br>? : 运算符<br>格式：条件表达式 ？表达式1：表达式2<br>含义：如果&lt;条件表达式&gt;为真，则执行&lt;表达式1&gt;，否则，&lt;执行表达式2&gt;</li></ul><h2 id="input-x2F-output-statement"><a href="#input-x2F-output-statement" class="headerlink" title="input&#x2F;output statement"></a>input&#x2F;output statement</h2><ul><li><strong>input statement</strong><br>标准的输入设备是键盘库 java.util.Scanner (after JDK1.5)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导入库</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">//import java.util.Scanner也行</span><br><br><span class="hljs-comment">//创建对象</span><br>Scanner Input=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br><span class="hljs-comment">//调用方法</span><br>Input.nextInt()      <span class="hljs-comment">//read int data</span><br>Input.nextByte() <span class="hljs-comment">//read byte data</span><br></code></pre></td></tr></table></figure><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><ul><li><strong>分支语句</strong></li></ul><ol><li><strong>if</strong>语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(<span class="hljs-type">boolean</span>-expression)<br>statement;<br></code></pre></td></tr></table></figure><p>功能：当boolean-expression为“真”时，执行statement 。<br>2. <strong>if    else</strong>语句<br>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(<span class="hljs-type">boolean</span>-expression)<br> statement1；<br><span class="hljs-keyword">else</span> statement2；<br></code></pre></td></tr></table></figure><p>功能：当 boolean-expression为“真”时，执行statement1； 否则，执行statement 2。<br>3. <strong>switch</strong>语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(expression)&#123;<br>      <span class="hljs-keyword">case</span> value1：statement1;<br>           <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> value2：statement2;<br>           <span class="hljs-keyword">break</span>;<br>         ┆         ┆<br>      <span class="hljs-keyword">case</span> valueN：statementN;<br>           <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span> : defaultStatement;<br>&#125;<br></code></pre></td></tr></table></figure><p>功能：将expression的值与value1~valueN匹配，如果匹配则执行对应的statement，然后退出；否则                   执行defaultStatement。</p><ul><li><strong>循环语句</strong></li></ul><ol><li><strong>for</strong>语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(initialization; termination; iteration)&#123;　　　　<br><span class="hljs-comment">//body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>功能：首先对循环条件（通常为i）进行initialization（初始化），然后执行termination（判断是否终止循环），然后执行循环体里的语句，最后执行iteration（循环条件i改变）</p><ol start="2"><li><strong>while</strong>语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">initialization<br><span class="hljs-title function_">while</span><span class="hljs-params">(termination)</span>&#123;　　　<br><span class="hljs-comment">//body;　      　</span><br>iteration;<br>&#125;<br></code></pre></td></tr></table></figure><p>功能：首先对循环条件（通常为i）进行initialization（初始化），然后执行termination（判断是否终止循环），然后执行循环体里的语句，最后执行iteration（循环条件i改变）</p><ol start="3"><li><strong>do while</strong>语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">initialization<br><span class="hljs-keyword">do</span>&#123;　　　<br><span class="hljs-comment">//body;　      　</span><br>iteration;<br>&#125;<span class="hljs-keyword">while</span>(termination);<br></code></pre></td></tr></table></figure><p>功能：首先对循环条件（通常为i）进行initialization（初始化），然后执行循环体里的语句，然后执行termination（判断是否终止循环），最后执行iteration（循环条件i改变）</p><p>注：<strong>while</strong>和<strong>do while</strong>语句的区别在于执行循环体和执行termination的顺序。</p><p>-<strong>跳转语句</strong></p><ol><li><p><strong>break</strong>语句<br>格式：break；<br>功能：终止当前循环体，转移到循环语句的下一条语句或标号处执行。</p></li><li><p><strong>continue</strong>语句<br> 格式：continue；<br> 功能： 跳过当前循环体的剩余语句，转移到下一次循环或标号处执行。</p></li><li><p><strong>return</strong>语句<br> 格式：return    [返回值]；<br>功能：终止方法或程序的执行，将控制返回调用者。</p></li></ol><h2 id="数组和向量"><a href="#数组和向量" class="headerlink" title="数组和向量"></a>数组和向量</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li><p><strong>一维数组的声明</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">arrayType  arrayName[];<br><br>arrayType []arrayName;<br></code></pre></td></tr></table></figure></li><li><p><strong>一维数组的创建</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数组元素为简单数据类型</span><br><br><span class="hljs-comment">//静态初始化</span><br> arrayType  arrayName[]=&#123;element1[,element2…]&#125;;<br>arrayType  []arrayName=&#123;element1[,element2…]&#125;;<br><span class="hljs-comment">//例如</span><br><span class="hljs-type">int</span> [] samllPrimes=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>&#125;;<br><br><span class="hljs-comment">//动态初始化</span><br>arrayName= <span class="hljs-keyword">new</span> <span class="hljs-title class_">arrayType</span>[arrayLength];<br><span class="hljs-comment">//声明与初始化合并</span><br>arrayType arrayName= <span class="hljs-keyword">new</span> <span class="hljs-title class_">arrayType</span>[arrayLength];<br><span class="hljs-comment">//例如</span><br><span class="hljs-type">int</span> arr[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>]<br><br><span class="hljs-comment">//数组元素为复合数据类型</span><br><br><span class="hljs-comment">//创建数组元素</span><br>arrayName= <span class="hljs-keyword">new</span> <span class="hljs-title class_">arrayType</span>[arrayLength];<br><span class="hljs-comment">//为数组元素开辟存储空间</span><br>arrayName[i]= <span class="hljs-keyword">new</span> <span class="hljs-title class_">arrayType</span>[paramList]<br><span class="hljs-comment">//例如</span><br>String  stringArray[];<br>   stringArray=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">3</span>];<br>   stringArray[<span class="hljs-number">0</span>]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(″Welcome″);<br>   stringArray[<span class="hljs-number">1</span>]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(″To″);<br>   stringArray[<span class="hljs-number">2</span>]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(″Zhnejiang″);<br></code></pre></td></tr></table></figure></li><li><p><strong>数组操作</strong><br> 引用数组元素，下标从0开始<br> 数组复制<br>   使用系统类的方法 ( System.arraycopy )。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *sourceArray             被复制的数组的数组名</span><br><span class="hljs-comment">  *sourcePosition      被复制的数组的起始位置</span><br><span class="hljs-comment">  *destinationArray  新数组的数组名</span><br><span class="hljs-comment">  *destinationposition 新数组储存复制的数组的起始位置</span><br><span class="hljs-comment">  *numberOfEntriesToCopy 需要被复制的元素个数</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">//导入所需的库</span><br>  <span class="hljs-keyword">import</span> java.io.*;<br><br>System.arraycopy( sourceArray, sourcePosition,<br>destinationArray, destinationposition, numberOfEntriesToCopy)<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><ul><li>是 java.util 包中的一个类，实现了类似动态数组的功能。</li><li>向量与数组的重要区别之一就是 向量的容量是可变的</li></ul><ol><li>向量的容量：向量的存储空间大小</li><li>向量的长度：线路的实际元素个数</li><li>向量的增量：向量的长度发生变化时，向量容量的增加量</li><li>增大容量时，向量的新容量取值：</li></ol><pre><code class=" mermaid">graph LRA[MAX] --&gt; B(向量的新长度)A --&gt; C(向量的原长度的2倍)C --&gt;增量等于0A --&gt; D(向量的原长度+容量增量)D --&gt; 增量大于0</code></pre><ul><li>声明格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Vector &lt;datatype&gt; variable_identifier;<br></code></pre></td></tr></table></figure><ul><li>构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">()</span><br><span class="hljs-comment">//创建空向量, 初始容量为 10 ,容量增量为 0 。</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span><br><span class="hljs-comment">//创建空向量, 初始容量为capacity, 容量增量为 0 。</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">int</span> capacityIncrement)</span><br><span class="hljs-comment">//创建空向量, 初始容量为 initialCapacity，容量增量为 capacityIncrement。</span><br></code></pre></td></tr></table></figure></li><li>添加元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Element obj)</span><br><span class="hljs-comment">//把element组件加到向量末尾，同时大小加1，向量容量比以前大1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addElement</span><span class="hljs-params">(Element obj)</span><br><span class="hljs-comment">//同上</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index,E element)</span><br><span class="hljs-comment">//把element组件加到指定处，此后的内容向后移动1 个单位。 注意与 insertElementAt 的不同参数。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertElementAt</span><span class="hljs-params">(E element,<span class="hljs-type">int</span> index)</span><br><span class="hljs-comment">//把element组件加到指定处，此后的内容向后移动1个单位</span><br></code></pre></td></tr></table></figure><ul><li>修改元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span><br><span class="hljs-comment">//用指定元素替换此向量中指定位置的元素。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setElementAt</span><span class="hljs-params">(E element,<span class="hljs-type">int</span> index)</span><br><span class="hljs-comment">//将此向量的指定索引处的组件设置为指定对象。</span><br></code></pre></td></tr></table></figure><ul><li>删除元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>    <span class="hljs-title function_">clear</span><span class="hljs-params">()</span><br><span class="hljs-comment">//Removes all of the elements from this Vector.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>   <span class="hljs-title function_">removeAllElement</span><span class="hljs-params">()</span><br><span class="hljs-comment">//Removes all components from this vector and sets its size to zero.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index )</span><br><span class="hljs-comment">//Removes the element at the specified position in this Vector.    Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the Vector.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeElementAt</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><br><span class="hljs-comment">//Deletes the component at the specified index.</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(object obj)</span><br><span class="hljs-comment">//Removes the first occurrence of the specified element in this Vector If the Vector does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists).</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(object obj)</span><br><span class="hljs-comment">//Removes the first (lowest-indexed) occurrence of the argument from this vector. If the object is found in this vector, each component in the vector with an index greater or equal to the object&#x27;s index is shifted downward to have an index one smaller than the value it had previously.</span><br></code></pre></td></tr></table></figure><ul><li>查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(object obj)</span><br><span class="hljs-comment">//Returns true if this vector contains the specified element.</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(object obj)</span><br><span class="hljs-comment">//Compares the specified Object with this Vector for equality.</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexof</span><span class="hljs-params">(object obj)</span><br><span class="hljs-comment">//Returns the index of the first occurrence of the specified element in this vector, or -1 if this vector does not contain the element.</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexof</span><span class="hljs-params">(object obj,<span class="hljs-type">int</span> index)</span><br><span class="hljs-comment">//Returns the index of the first occurrence of the specified element in this vector, searching forwards from index, or returns -1 if the element is not found.</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexof</span><span class="hljs-params">(object obj)</span><br><span class="hljs-comment">//Returns the index of the last occurrence of the specified element in this vector, or -1 if this vector does not contain the element.</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexof</span><span class="hljs-params">(object obj,<span class="hljs-type">int</span> index)</span><br><span class="hljs-comment">//Returns the index of the last occurrence of the specified element in this vector, searching backwards from index, or returns -1 if the element is not found.</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">capacity</span><span class="hljs-params">()</span><br><span class="hljs-comment">//Returns the current capacity of this vector.</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span><br><span class="hljs-comment">//Returns the number of components in this vector.</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span><br><span class="hljs-comment">//Tests if this vector has no components.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSize</span><span class="hljs-params">(<span class="hljs-type">int</span> newSize)</span><br><span class="hljs-comment">//Sets the size of this vector.</span><br></code></pre></td></tr></table></figure><ul><li>可在向量的任意位置插入不同类型的对象，无需考虑对象的类型，也无需考虑向量的容量。</li><li>向量只能存储对象，不能直接存储简单数据类型。</li><li>适合向量的场合:<br>频繁进行对象的插入和删除工作<br>需要处理的对象数目不定<br>列表成员全部都是对象，或者可以方便的用对象表示<br>需要很快确定列表内是否存在某一特定对象，并且需要很快了解到对象的存放位置</li><li>适合数组的场合:<br>所需处理的对象数目大致可以确定<br>所需处理的是简单数据类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>Summarize</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表浅谈</title>
    <link href="/2022/11/17/%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%B5%85%E8%B0%88/"/>
    <url>/2022/11/17/%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%B5%85%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="线性表的概念"><a href="#线性表的概念" class="headerlink" title="线性表的概念"></a>线性表的概念</h2><p>线性表，全名为线性储存结构。储存方式可以理解为“把所有数据用一根线串起来，再储存到物理空间中”。<br><img src="https://img-blog.csdnimg.cn/20200815133635360.gif#pic_center" alt="数据的线性结构"></p><h2 id="储存数据的特点"><a href="#储存数据的特点" class="headerlink" title="储存数据的特点"></a>储存数据的特点</h2><ul><li>具有“一对一”逻辑关系。</li><li>要求数据的数据类型必须一致。</li></ul><h2 id="线性表的分类"><a href="#线性表的分类" class="headerlink" title="线性表的分类"></a>线性表的分类</h2><p>线性表存储数据可分为<strong>顺序存储结构</strong>和<strong>链式存储结构</strong></p><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>将数据依次连续的存入一整块物理空间之中（简称顺序表），如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200815134201576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2gyNzYzMjQ2ODIz,size_16,color_FFFFFF,t_70#pic_center" alt="数据集中存放"></p><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>数据分散的存储在物理空间中，通过一根线保存着他们之间的逻辑关系（简称链表），如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200815134409696.png#pic_center" alt="数据分散存放"></p><h2 id="元素的前驱与后继"><a href="#元素的前驱与后继" class="headerlink" title="元素的前驱与后继"></a>元素的前驱与后继</h2><p>数据结构中，每个数据个体被称为“数据元素”（简称“元素”），每个元素都有前驱和后驱。</p><h3 id="前驱"><a href="#前驱" class="headerlink" title="前驱"></a>前驱</h3><ul><li>某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素统称为“前驱元素”。</li></ul><h3 id="后继"><a href="#后继" class="headerlink" title="后继"></a>后继</h3><ul><li>某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素统称为“后继元素”。</li></ul><p> 例如下图中数据<br><img src="https://img-blog.csdnimg.cn/20200815135039516.gif#pic_center" alt="前驱与后继"><br>对于3，2是它的直接前驱，4是它的直接后继；1和2则是它的前驱元素，4和5则是它的后继元素。</p>]]></content>
    
    
    <categories>
      
      <category>Summarize</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存对齐浅析</title>
    <link href="/2022/11/17/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%B5%85%E6%9E%90/"/>
    <url>/2022/11/17/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在了解内存对齐之前，我们先来做个简短的测试。<br>看看下面的代码输出的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>test t;<br>cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(t); <span class="hljs-comment">//输出结果是多少？</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你的答案是<strong>8</strong>，那么恭喜你答对了，不过相信很多人并不理解为什么是<strong>8</strong>，而不是<strong>5</strong>。按照正常思路，32位系统下，<strong>int</strong>占<strong>4</strong>个字节，<strong>char</strong>占<strong>1</strong>个字节，<strong>4+1&#x3D;5</strong>,所以<strong>t</strong>占<strong>5</strong>个字节，<strong>sizeof</strong>应该返回<strong>5</strong>，那为什么是<strong>8</strong>呢？<br>这就涉及到了文章的主题，<em><strong>内存对齐</strong></em>。</p><h2 id="内存对齐的原因"><a href="#内存对齐的原因" class="headerlink" title="内存对齐的原因"></a>内存对齐的原因</h2><p>原因主要分两部分，平台原因和性能原因。</p><h3 id="平台原因"><a href="#平台原因" class="headerlink" title="平台原因"></a>平台原因</h3><p>因为现代计算机中内存的最小单位是<strong>byte</strong>，所以从理论上讲似乎对任何类型的变量的访问可以从任何地址开始。<br>但是实际上有些硬件平台对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是<strong>某个数k（通常它为4或8）的倍数</strong> 。</p><h3 id="性能原因"><a href="#性能原因" class="headerlink" title="性能原因"></a>性能原因</h3><p>假如没有内存对齐机制，数据可以任意存放，现在一个<strong>int</strong>变量存放在从地址<strong>1</strong>开始的联系四个字节地址中，该处理器去取数据时，要先从<strong>0</strong>地址开始读取第一个<strong>4</strong>字节块,剔除不想要的字节（<strong>0</strong>地址）,然后从地址<strong>4</strong>开始读取下一个<strong>4</strong>字节块,同样剔除不要的数据（<strong>5，6，7</strong>地址）,最后留下的两块数据合并放入寄存器，这需要做很多工作。</p><h2 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h2><blockquote><p>每个特定平台上的编译器都有自己的默认“<strong>对齐系数</strong>”(也叫<strong>对齐模数</strong>)。程序员可以通过预编译命令#<strong>pragma pack(n)，n&#x3D;1,2,4,8,16</strong>来改变这一系数，其中的<strong>n</strong>就是你要指定的“<strong>对齐系数</strong>”。</p></blockquote><p>有效对其值：是给定值#pragma pack(n)和结构体中<strong>最长数据类型长度中较小的</strong>那个。有效对齐值也叫<strong>对齐单位</strong>。</p><h3 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h3><h4 id="1、数据成员对齐规则"><a href="#1、数据成员对齐规则" class="headerlink" title="1、数据成员对齐规则"></a>1、数据成员对齐规则</h4><blockquote><p><strong>结构(struct)</strong>(或<strong>联合(union)</strong>)的数据成员，第一个数据成员放在<strong>offset</strong>为<strong>0</strong>的地方，以后每个数据成员的对齐按照#pragma<br>pack指定的数值和这个数据成员自身长度中，<strong>比较小</strong>的那个进行。</p></blockquote><h4 id="2、结构-或联合-的整体对齐规则"><a href="#2、结构-或联合-的整体对齐规则" class="headerlink" title="2、结构(或联合)的整体对齐规则"></a>2、结构(或联合)的整体对齐规则</h4><blockquote><p>在数据成员完成各自对齐之后，<strong>结构(或联合)本身也要进行对齐</strong>，对齐将按照#pragma<br>pack指定的数值和结构(或联合)最大数据成员长度中，<strong>比较小</strong>的那个进行。</p></blockquote><h4 id="3、结合1、2"><a href="#3、结合1、2" class="headerlink" title="3、结合1、2"></a>3、结合1、2</h4><blockquote><p>当#pragma pack的<strong>n</strong>值<strong>等于或超过</strong>所有数据成员长度的时候，这个<strong>n</strong>值的大小将不产生任何效果。</p></blockquote><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">struct</span><br>&#123;<br>   <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> c2;<br>&#125;x1;<br><br><br><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">char</span> c2;<br>    <span class="hljs-type">int</span> i;<br>&#125;x2;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(x1) &lt;&lt; endl;  <span class="hljs-comment">// 输出12</span><br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(x2) &lt;&lt; endl;  <span class="hljs-comment">// 输出8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上测试都是在<strong>Win32</strong>环境下进行的，默认#<strong>pragma pack(4)<strong>，因此</strong>对齐单位</strong>为<strong>4</strong>。</p><p>以<strong>x1</strong>对象分析，首先使用<strong>对齐规则1</strong>，对<strong>x1</strong>的<strong>数据成员</strong>进行<strong>内存对齐</strong></p><p>sizeof(c1) &#x3D; 1 &lt; 4(<strong>对齐单位</strong>) 所以按照<strong>1</strong>字节对齐，占内存的第<strong>0</strong>单元。<br>sizeof(i) &#x3D; 4 &lt; &#x3D; 4(<strong>对齐单位</strong>) 相对于结构体首地址的偏移要为<strong>4</strong>的倍数，占内存的<strong>4,5,6,7</strong>单元。<br>sizeof(c2) &#x3D; 1 &lt; 4(<strong>对齐单位</strong>) 相对于结构体首地址的偏移要为<strong>4</strong>的倍数，占内存的第<strong>8</strong>单元。</p><p>接着，使用<strong>对齐规则2</strong>，对<strong>结构体整体</strong>进行<strong>内存对齐</strong>。</p><p><strong>x1</strong>中变量i占用内存最大占<strong>4</strong>字节，而有效对齐单位也为<strong>4</strong>字节，两者较小值就是<strong>4</strong>字节。因此<strong>整体也是按照4字节对齐</strong>。由<strong>对齐规则1</strong>得到<strong>x1</strong>占<strong>9</strong>个字节，此处再按照<strong>对齐规则2</strong>进行整体的<strong>4</strong>字节对齐，所以整个结构体占用<strong>12</strong>个字节。<img src="https://img-blog.csdnimg.cn/20200716221214388.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2gyNzYzMjQ2ODIz,size_16,color_FFFFFF,t_70#pic_center" alt="x1内存布局"><br><strong>x2</strong>对象的分析也是类似。<br>先套用<strong>对齐规则1</strong>，<strong>c1</strong>和<strong>c2</strong>都是按照<strong>1</strong>个字节对齐，分别占用内存的第<strong>0</strong>和<strong>1</strong>单元，<strong>i</strong>相对于结构体首地址的偏移要为<strong>4</strong>的倍数，占内存的<strong>4,5,6,7</strong>单元。<br>再套用<strong>对齐规则2</strong>，因此<strong>整体也是按照4字节对齐</strong>。由<strong>对齐规则1</strong>得到<strong>x2</strong>占<strong>8</strong>个字节，此处再按照<strong>对齐规则2</strong>进行整体的<strong>4</strong>字节对齐，所以整个结构体占用<strong>8</strong>个字节。</p><blockquote><p>参考资料：<br><a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/9537460?fr=aladdin">内存对齐_百度百科</a><br><a href="https://zhuanlan.zhihu.com/p/30007037">C&#x2F;C++内存对齐详解 - 知乎</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Summarize</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
