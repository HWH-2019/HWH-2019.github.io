---
title: 内存对齐浅析
author: HWH
tags: C++
categories: Summarize
abbrlink: fd01c924
date: 2022-11-17 21:39:20
---


## 引入
在了解内存对齐之前，我们先来做个简短的测试。
看看下面的代码输出的结果。

```cpp
#include<iostream>
using std::cout;

struct test{
	int x;
	char y;
};

int main(){

	test t;
	cout<<sizeof(t); //输出结果是多少？
	
	return 0;
}
```

如果你的答案是**8**，那么恭喜你答对了，不过相信很多人并不理解为什么是**8**，而不是**5**。按照正常思路，32位系统下，**int**占**4**个字节，**char**占**1**个字节，**4+1=5**,所以**t**占**5**个字节，**sizeof** 应该返回**5**，那为什么是**8**呢？
这就涉及到了文章的主题，***内存对齐***。

## 内存对齐的原因
原因主要分两部分，平台原因和性能原因。

### 平台原因
因为现代计算机中内存的最小单位是**byte**，所以从理论上讲似乎对任何类型的变量的访问可以从任何地址开始。
但是实际上有些硬件平台对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是**某个数k（通常它为4或8）的倍数** 。

### 性能原因
假如没有内存对齐机制，数据可以任意存放，现在一个**int**变量存放在从地址**1**开始的联系四个字节地址中，该处理器去取数据时，要先从**0**地址开始读取第一个**4**字节块,剔除不想要的字节（**0**地址）,然后从地址**4**开始读取下一个**4**字节块,同样剔除不要的数据（**5，6，7**地址）,最后留下的两块数据合并放入寄存器，这需要做很多工作。

## 内存对齐规则

> 每个特定平台上的编译器都有自己的默认“**对齐系数**”(也叫**对齐模数**)。程序员可以通过预编译命令#**pragma pack(n)，n=1,2,4,8,16**来改变这一系数，其中的**n**就是你要指定的“**对齐系数**”。

有效对其值：是给定值``#pragma pack(n)``和结构体中**最长数据类型长度中较小的**那个。有效对齐值也叫**对齐单位**。

### 对齐规则

#### 1、数据成员对齐规则

> **结构(struct)**(或**联合(union)**)的数据成员，第一个数据成员放在**offset**为**0**的地方，以后每个数据成员的对齐按照#pragma
> pack指定的数值和这个数据成员自身长度中，**比较小**的那个进行。

#### 2、结构(或联合)的整体对齐规则

> 在数据成员完成各自对齐之后，**结构(或联合)本身也要进行对齐**，对齐将按照#pragma
> pack指定的数值和结构(或联合)最大数据成员长度中，**比较小**的那个进行。

#### 3、结合1、2

> 当#pragma pack的**n**值**等于或超过**所有数据成员长度的时候，这个**n**值的大小将不产生任何效果。

## 案例分析
```cpp
#include<iostream>
using std::cout;
using std::endl;
struct
{
   char c1;
    int i;
    char c2;
}x1;


struct {
    char c1;
    char c2;
    int i;
}x2;

int main()
{
    cout << sizeof(x1) << endl;  // 输出12
    cout << sizeof(x2) << endl;  // 输出8
    return 0;
}
```
以上测试都是在**Win32**环境下进行的，默认#**pragma pack(4)**，因此**对齐单位**为**4**。

以**x1**对象分析，首先使用**对齐规则1**，对**x1**的**数据成员**进行**内存对齐**

sizeof(c1) = 1 < 4(**对齐单位**) 所以按照**1**字节对齐，占内存的第**0**单元。
sizeof(i) = 4 < = 4(**对齐单位**) 相对于结构体首地址的偏移要为**4**的倍数，占内存的**4,5,6,7**单元。
sizeof(c2) = 1 < 4(**对齐单位**) 相对于结构体首地址的偏移要为**4**的倍数，占内存的第**8**单元。

接着，使用**对齐规则2**，对**结构体整体**进行**内存对齐**。

**x1**中变量i占用内存最大占**4**字节，而有效对齐单位也为**4**字节，两者较小值就是**4**字节。因此**整体也是按照4字节对齐**。由**对齐规则1**得到**x1**占**9**个字节，此处再按照**对齐规则2**进行整体的**4**字节对齐，所以整个结构体占用**12**个字节。![x1内存布局](https://img-blog.csdnimg.cn/20200716221214388.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2gyNzYzMjQ2ODIz,size_16,color_FFFFFF,t_70#pic_center)
**x2**对象的分析也是类似。
先套用**对齐规则1**，**c1**和**c2**都是按照**1**个字节对齐，分别占用内存的第**0**和**1**单元，**i**相对于结构体首地址的偏移要为**4**的倍数，占内存的**4,5,6,7**单元。
再套用**对齐规则2**，因此**整体也是按照4字节对齐**。由**对齐规则1**得到**x2**占**8**个字节，此处再按照**对齐规则2**进行整体的**4**字节对齐，所以整个结构体占用**8**个字节。



> 参考资料：
> [内存对齐_百度百科](https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/9537460?fr=aladdin)
> [C/C++内存对齐详解 - 知乎](https://zhuanlan.zhihu.com/p/30007037)
